
# README.md

# Compiler Design Assignments

This repository contains **three assignments** related to compiler design concepts, including syntax analysis, semantic analysis, and practical applications in C++ programs. The assignments are designed to provide a deep understanding of parsing techniques, type checking, and scope management in compilers.

## Table of Contents

1. [Assignment 1: Difference Between Top-Down and Bottom-Up Parsing](#assignment-1-difference-between-top-down-and-bottom-up-parsing)
2. [Assignment 2: Type Mismatch Error](#assignment-2-type-mismatch-error)
3. [Assignment 3: Semantic Analysis – Scope & Symbol Table](#assignment-3-semantic-analysis-scope--symbol-table)
4. [Conclusion](#conclusion)


## Assignment 1: Difference Between Top-Down and Bottom-Up Parsing

### Introduction

Syntax analysis (parsing) is the **second phase of a compiler**, where the compiler checks if the tokens generated by the lexical analyzer follow the grammar rules of a programming language. Parsing constructs a **parse tree** to represent the grammatical structure of the program and reports syntax errors if the structure is invalid. Based on how parse trees are constructed, parsing techniques are divided into **Top-Down** and **Bottom-Up parsing**.

### Top-Down Parsing

Top-down parsing starts from the **start symbol** of the grammar and attempts to derive the input string by expanding non-terminals. The parse tree is built **from root to leaves**, and the parser tries to generate the **leftmost derivation**.

* **Working Principle:** The parser replaces non-terminals with production rules and matches the derived string with input tokens from left to right.
* **Examples:** Grammar `S → aSb | ε` and input `aabb` shows step-by-step derivation.
* **Types of Top-Down Parsers:** Recursive Descent Parsing (may involve backtracking) and Predictive Parsing (LL parsing, no backtracking).
* **Advantages:** Simple, intuitive, parse tree constructed directly.
* **Limitations:** Cannot handle left recursion, ambiguous grammars, or excessive backtracking.

### Bottom-Up Parsing

Bottom-up parsing starts from the **input string** and reduces it to the **start symbol** by reversing production rules. The parse tree is constructed **from leaves to root**, producing the **rightmost derivation in reverse**.

* **Working Principle:** Parser identifies substrings matching RHS of production rules and reduces them to non-terminals until the start symbol is reached.
* **Types:** Shift-Reduce Parsing (uses stack) and LR Parsers (LR(0), SLR(1), CLR(1), LALR(1)).
* **Advantages:** Handles left-recursive grammars, supports complex grammars, widely used in compilers.
* **Limitations:** More complex, larger parsing tables, harder to understand.

### Key Differences

| Feature                | Top-Down Parsing        | Bottom-Up Parsing              |
| ---------------------- | ----------------------- | ------------------------------ |
| Starting Point         | Start symbol            | Input string                   |
| Parse Tree Direction   | Root → Leaves           | Leaves → Root                  |
| Derivation             | Leftmost derivation     | Rightmost derivation (reverse) |
| Handles Left Recursion | No                      | Yes                            |
| Grammar Power          | Less powerful           | More powerful                  |
| Implementation         | Simple                  | Complex                        |
| Common Parsers         | LL, Recursive Descent   | LR, Shift-Reduce               |
| Used in Practice       | Rare in large compilers | Widely used                    |

### Practical Example: Balanced Curly Braces

A C++ program uses a **stack** to check for balanced `{}` in a string. This demonstrates syntax analysis in real applications.


## Assignment 2: Type Mismatch Error

### Introduction

A program must be **syntactically and semantically correct**. Syntax analysis checks grammar, while semantic analysis ensures logical correctness. **Type mismatch errors** occur when operations involve incompatible data types. These errors do not break grammar rules but violate the **meaning of operations**.

### Definition

A type mismatch error arises when a value of one type is used where another type is expected, or when an operation is applied to operands of incompatible types. These errors are detected during **semantic analysis**.

### Common Scenarios

1. **Assignment Mismatch:** Assigning a float to an integer variable without conversion.
2. **Expression Mismatch:** Adding incompatible types, e.g., int + char.
3. **Function Argument Mismatch:** Passing incorrect types to a function.
4. **Return Type Mismatch:** Function returns a value of a different type than declared.
5. **Relational/Logical Mismatch:** Using relational/logical operators on incompatible types.

### Detection in Compiler

During semantic analysis, the compiler uses a **symbol table** to track variable names, types, and scope. It verifies assignment, expression, and function call correctness, reporting errors when mismatches occur.

### Practical Example

```cpp
int a;
float b;
a = b + 2.5; // Type mismatch: float assigned to int
```

Semantic analysis detects this mismatch and prevents runtime errors.

### Real-World Applications

* Compiler safety: prevents incorrect operations.
* Large-scale software: ensures data integrity in banking/medical systems.
* Mobile/embedded systems: avoids crashes due to wrong memory usage.
* Strongly typed languages (Java, Kotlin, Swift) rely on type checking to catch errors early.

### Difference Between Syntax Error and Type Mismatch Error

| Aspect            | Syntax Error      | Type Mismatch Error    |
| ----------------- | ----------------- | ---------------------- |
| Phase             | Syntax Analysis   | Semantic Analysis      |
| Meaning           | Grammar violation | Meaning violation      |
| Example           | Missing semicolon | Assigning float to int |
| Program Structure | Incorrect         | Correct                |



## Assignment 3: Semantic Analysis – Scope & Symbol Table

### Introduction

Semantic analysis ensures programs respect **language rules for meaning and access control**. One important aspect is detecting **illegal access to private fields or methods**. This is accomplished using **scope rules** and a **symbol table**.

### Scope

Scope defines where an identifier (variable, method, or field) is visible. Object-oriented languages have **global, class, method, block, and nested class scopes**. Access modifiers (`public`, `private`, `protected`) enforce restrictions.

### Symbol Table

A **symbol table** stores information about identifiers:

* Name
* Data type
* Scope
* Access modifier
* Class ownership

It enables the compiler to check **access validity**.

### Private Members and Access Rules

Private members are accessible **only within the class**. Nested classes or friend-like structures may have controlled access depending on the language. Illegal access from outside is detected during semantic analysis.

### Practical Examples

* **Illegal Access**

```cpp
Student s;
s.age = 20; // 'age' is private → Error
```

* **Nested Class Access**

```cpp
Outer::Inner obj;
obj.show(outerObj); // Allowed if nested access rules permit
```

* **Friend-like Access**

```cpp
class Bank can access Account::balance via friend declaration
```

### Real-World Applications

* Software security: prevents unauthorized data access.
* Large software systems: enforces modular design.
* Compiler reliability: early detection of access violations.
* OOP principles: supports encapsulation and maintainable code.


## Conclusion

These assignments collectively cover **key aspects of compiler design**:

1. **Parsing Techniques:** Top-Down and Bottom-Up parsing, parse trees, and practical C++ applications.
2. **Type Checking:** Detecting type mismatch errors ensures program correctness and prevents runtime failures.
3. **Semantic Analysis:** Scope and symbol table management enforce access control, encapsulation, and secure program execution.

By combining theory with practical examples, these assignments demonstrate **how compilers analyze, validate, and enforce correctness** in programs, forming the foundation of reliable software systems.

---
